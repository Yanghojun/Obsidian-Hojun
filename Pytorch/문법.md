# Tensor 쌓기
`torch.cat`: 입력 텐서 유치한 채 **연결**.
- dim:0 -> row 방향으로 연결한다. 이미지 2장이 있다면 이를 1개의 큰 이미지로 합친다.
- dim:1 -> col 방향으로 연결한다.
입력 tensor 차원에서 dim 방향으로 차원 크기가 커진다.
```python

import torch

a = torch.tensor([[1, 2], [3, 4]])
b = torch.tensor([[5, 6], [7, 8]])

# torch.cat 사용 (차원 0을 따라 연결)
result_cat0 = torch.cat([a, b], dim=0)
# 결과: tensor([[1, 2],
#              [3, 4],
#              [5, 6],
#              [7, 8]])
# 크기: torch.Size([4, 2])

# torch.cat 사용 (차원 1을 따라 연결)
result_cat1 = torch.cat([a, b], dim=1)
# 결과: tensor([[1, 2, 5, 6],
#              [3, 4, 7, 8]])
# 크기: torch.Size([2, 4])
```
`torch.stack`: 입력 텐서 새로 **쌓는다**
입력 데이터가 (Batch, num feature), (Batch, num feature) 로 존재한다고 하자. 동일 유저들에 대한 feature를 아침, 점심 시간에 각각 측정해 본 것이다.

- `dim=1`: (Batch, torch.stack에 입력한 리스트 길이, num_feature)
	- Batch는 A유저, B유저에 대한 인덱스였다고 가정하면, torch.stack 이후에도 Batch에 A유저, B유저에 대한 텐서가 접근된다.
	- [0, 0, :] -> A유저의 첫번째 측정한 모든 feature들
	- [1, 1, :] -> B유저의 두번째 시간에 측정한 모든 feature들
- dim=2: (Batch, num_feature, torch.stack에 입력한 리스트 길이)
	- [0, 0, :] -> A유저의 첫번째 feature의 두개 값(첫번째 시간, 두번째 시간에 측정한 값
- dim:0 -> 가장 첫번째 인덱스에 데이터 수만큼 차원이 생긴다. 이미지 2장이 있다면 이를 2개 배치로 만든다. (3, 3), (3, 3)으로 각각 존재하던 이미지를 (2, 3, 3)으로 배치 이미지로 만든다.
- dim:1 -> 두번째 인덱스에 데이터 수 만큼 차원이 생긴다. 동일 유저의 시간 별 특징 변화를 측정한다고 가정하자. 두명의 유저의 특징 3개를 t0시간에 저장한 (2, 3) tensor, t1 시간에 저장한 (2, 3) tensor가 있다고 할 때 (2, 2, 3) 으로 2개 유저에 대해 시간 차원을 추가할 수 있다.
입력 tensor 차원에서 dim 수에 새로운 차원이 생긴다.
```python
import torch

# 2개의 2x2 텐서 생성
a = torch.tensor([[1, 2], [3, 4]])
b = torch.tensor([[5, 6], [7, 8]])

# 차원 0을 따라 쌓기 (기본값)
result = torch.stack([a, b])
# 결과: tensor([[[1, 2],
#               [3, 4]],
# 
#              [[5, 6],
#               [7, 8]]])
# 크기: torch.Size([2, 2, 2])

# 차원 1을 따라 쌓기
result = torch.stack([a, b], dim=1)
# 결과: tensor([[[1, 2],
#               [5, 6]],
# 
#              [[3, 4],
#               [7, 8]]])
# 크기: torch.Size([2, 2, 2])
```